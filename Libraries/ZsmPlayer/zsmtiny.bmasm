import BM="BM.bmasm";
import Init="Initialisation.bmasm";

public static void Setup()
{

}

private static Action? Proc = null;

public static ZsmPlayer Create()
{
    return new ZsmPlayer();
}

public class ZsmPlayer
{
    private bool UsesYm = false;
    private bool UsesPsg = false;
    private bool UsesExtCommands = false;
    private bool UsingZp = false;
    private int RamBank = -1;

    private bool HasOverrides = false;

    public ZsmPlayer WithYm()
    {
        UsesYm = true;
        HasOverrides = true;
        return this;
    }

    public ZsmPlayer WithPsg()
    {
        UsesPsg = true;
        HasOverrides = true;
        return this;
    }

    public ZsmPlayer WithExtCommands()
    {
        UsesExtCommands = true;
        HasOverrides = true;
        return this;
    }

    public ZsmPlayer UseZp()
    {
        UsingZp = true;
        HasOverrides = true;
        return this;
    }

    public ZsmPlayer UseRamBank(int bank)
    {
        RamBank = bank;
        HasOverrides = true;
        return this;
    }

    public void Build()
    {
        Proc = () =>
        {

        if (!HasOverrides)
        {
            UsesYm = true;
            UsesPsg = true;
            UsesExtCommands = true;
            UsingZp = false;
        }

if (UsingZp)
{
.segment ZP scope:ZsmPlayer
    .padvar ushort data_pointer
.endsegment
}

.scope ZsmPlayer
.constvar uint psg_start = 0x1f9c0

.proc get_byte

    inc data_pointer
    bne +skip
    inc data_pointer + 1
    lda data_pointer + 1
    cmp #$c0
    bne +skip

    lda RAM_BANK
    inc
    sta RAM_BANK
    sta tick:ram_bank
    lda #$a0
    sta data_pointer + 1
    stz data_pointer

.skip:
if (UsingZp)
{
    lda (data_pointer)
}
else
{
    lda data_pointer: $a00f        ; updated above, starting a byte before the end of the header, do like this so flags are right
}
    rts

.endproc

.proc tick

    lda countdown: #$00
    beq tick_setup

    dec countdown
    rts

.tick_setup:
    lda ram_bank: #$ab
    sta RAM_BANK

.tick_loop:
    jsr get_byte

    bmi exit

if (UsesPsg)
{
    ldy ADDRx_H
    sty addr_h
    ldy ADDRx_M
    sty addr_m
    ldy ADDRx_L
    sty addr_l

    ldy #^psg_start
    sty ADDRx_H
    ldy #>psg_start
    sty ADDRx_M
}

    ; 0x00xx_xxxx - Vera write
    ; 0x0100_0000 - Ext Command
    ; 0x01xx_xxxx - YM write

if (UsesExtCommands || UsesYm)
{
    tax
}
if (UsesPsg && (UsesExtCommands || UsesYm))
{
    and #0b0100_0000
    bne ext_or_ym
}

if (UsesPsg)
{
.vera:
    clc
if (UsesExtCommands || UsesYm)
{
    txa
}
    adc #<psg_start
    sta ADDRx_L

    jsr get_byte
    sta DATA0
    bra -tick_loop
}

.ext_or_ym:
if (UsesPsg && (UsesExtCommands || UsesYm))
{
    txa
}
if (UsesExtCommands && UsesYm)
{
    and #0b0011_1111
    beq ext_command
}

if (UsesYm)
{
; use the masked value in .A for the loop via .Y
.ym:
    tay

.ym_loop:
.:  bit $9f41
    bmi -
    jsr get_byte
    sta $9f40
    jsr get_byte
    sta $9f41

    dey
    bne -ym_loop
    bra -tick_loop
}

if (UsesExtCommands)
{
.ext_command:
    jsr get_byte
    ; returns 0xccnn_nnnn - cc = command, nnnnnnnn = length
    and #0b0011_1111
    tax

.:  beq -tick_loop
    jsr get_byte
    dex
    bra -
}

.exit:
if (UsesPsg)
{
    ldy addr_h: #$ab
    sty ADDRx_H
    ldy addr_m: #$ab
    sty ADDRx_M
    ldy addr_l: #$ab
    sty ADDRx_L
}

    and #$7f
    beq all_done
    dec
    sta countdown

.step_done:
    rts

.all_done:
    ; loop or flag or whatever
if (RamBank == -1)
{
    lda done_ram_bank: #$00
    sta tick:ram_bank

    if (UsingZp)
    {
    lda #<$a00f
    sta data_pointer
    lda #>$a00f
    sta data_pointer + 1
    }
    else
    {
    lda #<$a00f
    sta get_byte:data_pointer
    lda #>$a00f
    sta get_byte:data_pointer + 1
    }
    rts
}
; falls though
.endproc

.proc init_player

if (RamBank == -1)
{
    lda RAM_BANK
    sta tick:ram_bank
    sta tick:done_ram_bank
}
else
{
    lda #@(RamBank)     ; Ram Bank
    sta tick:ram_bank
}

if (UsingZp)
{
    lda #<$a00f
    sta data_pointer
    lda #>$a00f
    sta data_pointer + 1
}

    rts

.endproc

.endscope
        };
    }
}

public override void Initialise()
{
    Setup();
}

public void Generate()
{
    if (Proc == null)
    {
        var p = Create();
        p.Build();
    }

    Proc();
}
