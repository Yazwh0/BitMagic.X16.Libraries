import BM="BM.bmasm";
import Init="Initialisation.bmasm";

public static void Setup()
{

}

private static Action? Proc = null;

public static ZsmPlayer Create()
{
    return new ZsmPlayer();
}

public class ZsmPlayer
{
    private bool UsesYm = false;
    private bool UsesPsg = false;
    private bool UsesExtCommands = false;

    private bool HasOverrides = false;

    public ZsmPlayer WithYm()
    {
        UsesYm = true;
        HasOverrides = true;
        return this;
    }

    public ZsmPlayer WithPsg()
    {
        UsesPsg = true;
        HasOverrides = true;
        return this;
    }

    public ZsmPlayer WithExtCommands()
    {
        UsesExtCommands = true;
        HasOverrides = true;
        return this;
    }

    public void Build()
    {
        Proc = () =>
        {

        if (!HasOverrides)
        {
            UsesYm = true;
            UsesPsg = true;
            UsesExtCommands = true;
        }

.scope ZsmPlayer
.constvar uint psg_start = 0x1f9c0

.proc get_byte

    inc read_position
    bne +skip
    inc read_position + 1
    lda read_position + 1
    cmp #$c0
    bne +skip

    inc RAM_BANK
    lda #$a0
    sta read_position + 1
    stz read_position

.skip:
    lda read_position: $a00f        ; updated above, starting a byte before the end of the header, do like this so flags are right

    rts

.endproc

.proc tick

    lda countdown: #$00
    beq tick_loop

    dec countdown
    rts

.tick_loop:
    jsr get_byte

    bmi exit

if (UsesPsg)
{
    ldy ADDRx_H
    sty addr_h
    ldy ADDRx_M
    sty addr_m
    ldy ADDRx_L
    sty addr_l

    ldy #^psg_start
    sty ADDRx_H
    ldy #>psg_start
    sty ADDRx_M
}

    ; 0x00xx_xxxx - Vera write
    ; 0x0100_0000 - Ext Command
    ; 0x01xx_xxxx - YM write

    tax
if (UsesPsg && (UsesExtCommands || UsesYm))
{
    and #0b0100_0000
    bne ext_or_ym
}

if (UsesPsg)
{
.vera:
    clc
    txa
    adc #<psg_start
    sta ADDRx_L

    jsr get_byte
    sta DATA0
    jmp -tick_loop
}

.ext_or_ym:
if (UsesPsg && (UsesExtCommands || UsesYm))
{
    txa
}
if (UsesExtCommands && UsesYm)
{
    and #0b0011_1111
    beq ext_command
}

if (UsesYm)
{
; use the masked value in .A for the loop via .Y
.ym:
    tay

.ym_loop:
.:  bit $9f41
    bmi -
    jsr get_byte
    sta $9f40
    jsr get_byte
    sta $9f41

    dey
    bne -ym_loop
    jmp -tick_loop
}

if (UsesExtCommands)
{
.ext_command:
    jsr get_byte
    ; returns 0xccnn_nnnn - cc = command, nnnnnnnn = length
    and #0b0011_1111
    tax

.:  beq -tick_loop
    jsr get_byte
    dex
    jmp -
}

.exit:
if (UsesPsg)
{
    ldy addr_h: #$ab
    sty ADDRx_H
    ldy addr_m: #$ab
    sty ADDRx_M
    ldy addr_l: #$ab
    sty ADDRx_L
}

    and #$7f
    beq all_done
    dec
    sta countdown

.step_done:
    rts

.all_done:
    ; loop or flag or whatever
    lda ram_bank: #$00
    sta RAM_BANK
    lda #<$a00f
    sta get_byte:read_position
    lda #>$a00f
    sta get_byte:read_position + 1
    rts

.endproc

.proc init_player

    lda RAM_BANK
    sta tick:ram_bank
    rts

.endproc

.endsegment
        };
    }
}

public override void Initialise()
{
    Setup();
}

public void Generate()
{
    if (Proc == null)
    {
        var p = Create();
        p.Build();
    }

    Proc();
}
