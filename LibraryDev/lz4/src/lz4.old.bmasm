import BM="BM.bmasm";
import Init="Initialisation.bmasm";

public static void Setup()
{
.segment Bss, scope:Lz4
    .padvar byte step
    .padvar byte decompress_state
    .padvar ushort block_length
    .padvar ushort copy_length
    .padvar ushort copy_lookback
    .padvar ushort this_byte_count	; 16 bit counter for this iteration
    .padvar ushort source_length	; 16 bit counter for total source length
	.padvar ushort this_length		; how many bytes are to be read this time -- min of the legnth or the count from the source
	.padvar byte all_done			; used to incidate that this iteration is the last
.endsegment
}

private static List<Action> Procs = new List<Action>();

public static Lz4Decompressor Create()
{
	return new Lz4Decompressor();
}

public class Lz4Decompressor
{
	internal Action ReadSource { get; set; }
	internal Action WriteDestination { get; set; }
	internal Action SetLookback { get; set; }
	internal Action SetReadLength { get; set; }
	internal List<Action> InitialisationProcs { get; set; } = new();
	internal bool Debugging { get; set; } = false;

	public Lz4Decompressor FromRam(string sourceData)
	{
		InitialisationProcs.Add(() =>
		{
			lda #<@(sourceData)
			sta getbyte:read_pos
			lda #>@(sourceData)
			sta getbyte:read_pos + 1
		});

		ReadSource = () =>
		{
			; read from RAM
			lda read_pos: $abcd
			inc read_pos
			bne exit
			inc read_pos + 1
		};

		return this;
	}

	public Lz4Decompressor FromSpi()
	{
		ReadSource = () =>
		{
			lda SPI_DATA
		};

		return this;
	}

	public Lz4Decompressor ToRam(string desination)
	{
		InitialisationProcs.Add(() =>
		{
			lda #<@(desination)
			sta writebyte:write_pos
			lda #>@(desination)
			sta writebyte:write_pos + 1
		});

		WriteDestination = () =>
		{
			sta write_pos: $abcd
			inc write_pos
			bne exit
			inc write_pos + 1
		};

		SetLookback = () =>
		{
			sec
			lda writebyte:write_pos
			sbc copy_lookback
			sta lookback

			lda writebyte:write_pos + 1
			sbc copy_lookback + 1
			sta lookback + 1
		};

		return this;
	}

	public Lz4Decompressor WithReadLength(ushort length)
	{
		SetReadLength = () =>
		{
			lda #<@(length)
			sta this_byte_count
			lda #>@(length) + 1
			sta this_byte_count + 1
		};

		return this;
	}

	public Lz4Decompressor WithReadLengthXY()
	{
		SetReadLength = () =>
		{
			stx this_byte_count
			iny
			sty this_byte_count + 1
		};

		return this;
	}

	public Lz4Decompressor WithDebugging()
	{
		Debugging = true;
		return this;
	}

	public void Build()
	{
		Procs.Add(() =>
		{
		.scope Lz4

		.const GET_INIT_LENGTH = 0
		.const GET_LITTERAL_LENGTH = 1 << 1
		.const WRITE_LITTERAL = 2 << 1
		.const GET_LOOKBACK_L = 3 << 1
		.const GET_LOOKBACK_H = 4 << 1
		.const GET_COPY_LENGTH = 5 << 1
		.const WRITE_COPY = 6 << 1

		.const MORE_LITTERAL_LENGTH = 0x13
		.constvar byte ptr next_byte = getbyte:read_pos

		.proc decompress_init

			stx source_length
			iny
			sty source_length + 1

			foreach (var initProc in InitialisationProcs)
				initProc();

			stz decompress_state

			rts
		.endproc

		; compress data from the input.
		; $YYXX max input bytes to read
		.proc decompress

			SetReadLength();

			; set this_byte_count to the min of itself and source_length -- we do this so we only need to have one counter
			; compare high bytes,
			lda this_byte_count + 1
			cmp source_length + 1
			bcc set_this_length		; carry is set if source_length is higher
			bne replace				; not equal, so source_length is lower, other wise check lower byte

			lda this_byte_count
			cmp source_length
			bcc set_this_length
			beq set_this_length

		.replace:
			lda source_length
			sta this_byte_count
			lda source_length + 1
			sta this_byte_count + 1

		.set_this_length:
			lda this_byte_count
			sta this_length
			lda this_byte_count + 1
			sta this_length + 1

		.done:
			ldx decompress_state
			if (Debugging) {
			inc step 						; for debugging
			}
			jmp (state_jumptable, x)

		.state_jumptable:
			.word get_length_init
			.word get_litteral_length
			.word write_litteral
			.word get_lookback_l
			.word get_lookback_h
			.word get_copy_length
			.word write_copy

		.decompress_exit:
			clc								; indicate we're not done
			rts

		.decompress_done:
			dec this_byte_count + 1			; to indicate how many bytes are left from the requested amount
			sec								; indicate we're done
			rts

		.endproc

		.proc get_length_init

			if (Debugging) {
			; unnecessary, but handy for debugging
			stz block_length
			stz copy_length
			}

			lda #1
			sta copy_length + 1				; set to 1, as we add to this we can start from here
			sta block_length + 1

			jsr getbyte

			; need to do something with the low bits
			tax
			clc
			and #$f
			adc #4
			sta copy_length					; gets completed after the literal block

			txa
			lsr
			lsr
			lsr
			lsr
			beq no_litteral
			sta block_length
			cmp #$0f
			beq more_length

			ldx #WRITE_LITTERAL				; write litteral to output
			stx decompress_state
			jmp decompress:done

		.more_length:
			ldx #GET_LITTERAL_LENGTH		; keep reading length data
			stx decompress_state
			jmp decompress:done

		.no_litteral:
			lda #GET_LOOKBACK_L
			sta decompress_state			; we have the copy offset already
			jmp decompress:done

		.all_done:
			jmp decompress:decompress_done

		.endproc

		.proc get_litteral_length

		.loop:
			jsr getbyte
			beq done

			tax								; keep so we can check if its not $ff
			clc
			adc block_length
			sta block_length
			lda block_length + 1
			adc #0
			sta block_length + 1

			cpx #$ff
			beq -loop

		.done:
			ldx #WRITE_LITTERAL
			stx decompress_state
			jmp decompress:done
		.endproc

		.proc get_copy_length
		.loop:
			jsr getbyte
			beq done

			tax								; keep so we can check if its not $ff
			clc
			adc copy_length
			sta copy_length
			lda copy_length + 1
			adc #0
			sta copy_length + 1

			cpx #$ff
			beq -loop

		.done:
			ldx #WRITE_COPY					; copy litteral
			stx decompress_state
			jmp decompress:done

		.endproc

		.proc get_lookback_l
			jsr getbyte
			sta copy_lookback

			ldx #GET_LOOKBACK_H				; get high byte of lookback
			stx decompress_state
			jmp decompress:done
		.endproc

		.proc get_lookback_h
			jsr getbyte
			sta copy_lookback + 1

			lda copy_length
			beq no_copy
			cmp #MORE_LITTERAL_LENGTH
			beq next_copy_length

			ldx #WRITE_COPY					; write copy
			stx decompress_state
			jmp decompress:done

		.next_copy_length:
			lda #GET_COPY_LENGTH
			sta decompress_state			; read the length of the copy
			jmp decompress:done

		.no_copy:
			stz decompress_state			; read the length of the copy
			jmp decompress:done
			jmp decompress:decompress_done	; all done!
		.endproc

		.proc write_copy

			SetLookback();
		.loop:
			lda lookback: $abcd
			jsr writebyte

			inc lookback
			bne skip
			inc lookback + 1

		.skip:
			dec copy_length
			bne -loop
			dec copy_length + 1
			bne -loop

			stz decompress_state
			jmp decompress:done

		.endproc

		.proc write_litteral

		.loop:
			jsr getbyte
			jsr writebyte

			dec block_length
			bne -loop
			dec block_length + 1
			bne -loop

			lda #GET_LOOKBACK_L
			sta decompress_state			; we have the copy offset already
			jmp decompress:done


		.endproc

		; returns the next byte from the input in .A
		.proc getbyte
			dec source_length
			bne +
			dec source_length + 1
			beq all_done

		.:	dec this_byte_count
			bne +
			dec this_byte_count + 1
			beq this_batch_done

		.:
			ReadSource();
		.exit:
			rts

		; exhausted bytes requested, clear up the stack and jump out
		.this_batch_done:
			pla
			pla
			jmp decompress:decompress_exit

		.all_done:
			pla
			pla
			jmp decompress:decompress_done

		.endproc

		; write a byte to the output
		.proc writebyte

			WriteDestination();
		.exit:
			rts

		.endproc
		.endscope
		});
	}
}

public override void Initialise()
{
    Setup();
}

public void Generate()
{
    foreach (var proc in Procs)
        proc();
}
